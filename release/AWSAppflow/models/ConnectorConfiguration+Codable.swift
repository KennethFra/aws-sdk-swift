// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension AppflowClientTypes.ConnectorConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case canUseAsDestination
        case canUseAsSource
        case connectorMetadata
        case isPrivateLinkEnabled
        case isPrivateLinkEndpointUrlRequired
        case supportedDestinationConnectors
        case supportedSchedulingFrequencies
        case supportedTriggerTypes
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if canUseAsDestination != false {
            try encodeContainer.encode(canUseAsDestination, forKey: .canUseAsDestination)
        }
        if canUseAsSource != false {
            try encodeContainer.encode(canUseAsSource, forKey: .canUseAsSource)
        }
        if let connectorMetadata = connectorMetadata {
            try encodeContainer.encode(connectorMetadata, forKey: .connectorMetadata)
        }
        if isPrivateLinkEnabled != false {
            try encodeContainer.encode(isPrivateLinkEnabled, forKey: .isPrivateLinkEnabled)
        }
        if isPrivateLinkEndpointUrlRequired != false {
            try encodeContainer.encode(isPrivateLinkEndpointUrlRequired, forKey: .isPrivateLinkEndpointUrlRequired)
        }
        if let supportedDestinationConnectors = supportedDestinationConnectors {
            var supportedDestinationConnectorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supportedDestinationConnectors)
            for connectortypelist0 in supportedDestinationConnectors {
                try supportedDestinationConnectorsContainer.encode(connectortypelist0.rawValue)
            }
        }
        if let supportedSchedulingFrequencies = supportedSchedulingFrequencies {
            var supportedSchedulingFrequenciesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supportedSchedulingFrequencies)
            for schedulingfrequencytypelist0 in supportedSchedulingFrequencies {
                try supportedSchedulingFrequenciesContainer.encode(schedulingfrequencytypelist0.rawValue)
            }
        }
        if let supportedTriggerTypes = supportedTriggerTypes {
            var supportedTriggerTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supportedTriggerTypes)
            for triggertypelist0 in supportedTriggerTypes {
                try supportedTriggerTypesContainer.encode(triggertypelist0.rawValue)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let canUseAsSourceDecoded = try containerValues.decode(Swift.Bool.self, forKey: .canUseAsSource)
        canUseAsSource = canUseAsSourceDecoded
        let canUseAsDestinationDecoded = try containerValues.decode(Swift.Bool.self, forKey: .canUseAsDestination)
        canUseAsDestination = canUseAsDestinationDecoded
        let supportedDestinationConnectorsContainer = try containerValues.decodeIfPresent([AppflowClientTypes.ConnectorType?].self, forKey: .supportedDestinationConnectors)
        var supportedDestinationConnectorsDecoded0:[AppflowClientTypes.ConnectorType]? = nil
        if let supportedDestinationConnectorsContainer = supportedDestinationConnectorsContainer {
            supportedDestinationConnectorsDecoded0 = [AppflowClientTypes.ConnectorType]()
            for string0 in supportedDestinationConnectorsContainer {
                if let string0 = string0 {
                    supportedDestinationConnectorsDecoded0?.append(string0)
                }
            }
        }
        supportedDestinationConnectors = supportedDestinationConnectorsDecoded0
        let supportedSchedulingFrequenciesContainer = try containerValues.decodeIfPresent([AppflowClientTypes.ScheduleFrequencyType?].self, forKey: .supportedSchedulingFrequencies)
        var supportedSchedulingFrequenciesDecoded0:[AppflowClientTypes.ScheduleFrequencyType]? = nil
        if let supportedSchedulingFrequenciesContainer = supportedSchedulingFrequenciesContainer {
            supportedSchedulingFrequenciesDecoded0 = [AppflowClientTypes.ScheduleFrequencyType]()
            for string0 in supportedSchedulingFrequenciesContainer {
                if let string0 = string0 {
                    supportedSchedulingFrequenciesDecoded0?.append(string0)
                }
            }
        }
        supportedSchedulingFrequencies = supportedSchedulingFrequenciesDecoded0
        let isPrivateLinkEnabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isPrivateLinkEnabled)
        isPrivateLinkEnabled = isPrivateLinkEnabledDecoded
        let isPrivateLinkEndpointUrlRequiredDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isPrivateLinkEndpointUrlRequired)
        isPrivateLinkEndpointUrlRequired = isPrivateLinkEndpointUrlRequiredDecoded
        let supportedTriggerTypesContainer = try containerValues.decodeIfPresent([AppflowClientTypes.TriggerType?].self, forKey: .supportedTriggerTypes)
        var supportedTriggerTypesDecoded0:[AppflowClientTypes.TriggerType]? = nil
        if let supportedTriggerTypesContainer = supportedTriggerTypesContainer {
            supportedTriggerTypesDecoded0 = [AppflowClientTypes.TriggerType]()
            for string0 in supportedTriggerTypesContainer {
                if let string0 = string0 {
                    supportedTriggerTypesDecoded0?.append(string0)
                }
            }
        }
        supportedTriggerTypes = supportedTriggerTypesDecoded0
        let connectorMetadataDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ConnectorMetadata.self, forKey: .connectorMetadata)
        connectorMetadata = connectorMetadataDecoded
    }
}
